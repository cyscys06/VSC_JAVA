중급 자바 1편

java.lang 패키지: 자바 언어의 기본적인 클래스들을 담아놓은 패키지(C++의 STL같은거)

Object : 모든 자바 객체의 부모 클래스
String : 문자열
Integer, Long, Double : 래퍼 타입, 기본형 데이터 타입을 객체로 만든 것
Class : 클래스 메타 정보
System : 시스템과 관련된 기본 기능들을 제공

import 생략 가능
java.lang 패키지 안에 있는 모든 클래스는 자동으로 임포트 돼있는 상태임


클래스 기능 설명

Object
- 클래스에 상속 받을 부모 클래스가 없으면 묵시적으로 `Object` 클래스를 상속

- 쉽게 이야기해서 자바가 `extends Object` 코드를 자동으로 넣어줌

- 따라서 `extends Object` 는 생략하는 것을 권장

- 반대로 자식클래스가 상속받을 부모클래스 명시적으로 표시하면 자바에서 오브젝트 클래스 자동으로 상속 안시켜줌

- 사용자가 생성하는 모든 클래스에 공통기능을 제공하기 위해, 그리고 다형성의 기본 구현을 위해 오브젝트 클래스를 최상위 부모 클래스로 구현함

- Object` 가 제공하는 기능은 다음과 같음
객체의 정보를 제공하는 toString()
객체의 같음을 비교하는 equals()
객체의 클래스 정보를 제공하는 getClass()
기타 등등

- 오브젝트는 최상위 부모 클래스이므로 모든 객체를 다 담을 수 있음. 
메서드에서도 매개변수로 오브젝트 타입을 쓰면 어떤 클래스던 다 인자로 받을 수 있음. 
하지만 전달받은 객체를 호출하려면 그 객체에 맞게 다운캐스팅 해야함

- 응용: 오브젝트를 배열 형태로 만들면 서로 다른 클래스의 객체들을 배열에 담을 수 있음

- size(): 오브젝트 배열의 원소의 개수 반환 메서드

- System.out.println() 메서드는 사실 내부에서 toString() 을 호출해서, sout이랑 toString을 호출한 결과가 같음

- equals(): 필요에 따라 오버라이딩하여 객체가 논리적으로 같은지를 비교하는 메서드(객체의 문자열을 비교하는 식으로 해서 두 객체를 비교할 수 있음
-> ==연산자는 같은값을 가진 서로 다른 두 객체 비교했을때 객체의 값이 아니라 참조값을 비교해서, 객체가 같은 값을 가져도 false가 뜰 것


오브젝트를 배열로 선언하면 오브젝트 클래스의 모든 하위 클래스를 원소로 넣을 수 있음


2장

- 사이드 이펙트: 프로그램의 특정 부분에서 발생한 변경이 의도치 않게 다른 부분에 영향을 미치는 경우를 말함

- 여러 변수가 하나의 객체를 참조하는 공유 참조를 막을 수 있는 방법은 없음

- 불변 객체: 객체의 상태(속성)이 변하지 않는 객체
단순히 클래스의 필드를 final로 선언하면 그게 불변 객체임
불변 필드로만 구성된 클래스도 곧 불변 클래스임

- 불변이라는 단순한 제약을 사용해서 사이드 이펙트라는 큰 문제를 막을 수 있음(일부러 컴파일 오류가 뜨게 해서 새로운 객체를 하나 더 만들게 하는 것)

- 불변객체의 기존 값을 변경하지 않는 대신, 그 값을 이용한 특정 계산 결과를 바탕으로 새로운 객체를 만들고 반환한다 -> 그냥 새로운 객체가 만들어지는거임


3장

- String 클래스 내부: 자바9 이전 char[], 자바9이후 byte[](영어 한글자 1바이트라서)
-> byte[]가 메모리 더 효율적으로 사용

- String 클래스 주요 메서드
length(): 문자열의 길이를 반환
charAt(int index): 특정 인덱스의 문자를 반환
substring(int beginIndex, int endIndex): 문자열의 부분 문자열을 반환
indexOf(String str): 특정 문자열이 시작되는 인덱스를 반환
toLowerCase(), toUpperCase(): 문자열 전체를 소문자 또는 대문자로 변환
trim(): 문자열 양 끝의 공백을 제거
concat(String str): 문자열끼리 더함

- String은 불변 객체이므로 각종 연산 불가 -> 가변인 객체 String을 StringBuilder 클래스에서 만들수 있음

- String끼리 비교할때는 == 연산자 말고 equals() 메서드 써야함
== 연산자는 서로 다른 객체인것만 봐서 false
equals() 메서드는 논리적으로 같은 객체인걸로 쳐서 true'


- 문자열 리터럴(객체로 안만들고 문자열 그대로 만드는것)으로 하면 true 뜨는 이유: 
1. 사용자가 리터럴로 선언하면 컴파일러에서 String 객체를 미리 만들어둠
2. 만들어논 객체에 리터럴 문자열 넣음
3. 이때 리터럴 문자열 하나 더 발견, 아까와 같은 문자열임
4. 같은 문자열이므로 이미 문자열 담아놨던 객체의 참조값을 똑같이 줌
5. 결론적으로 두 문자열이 같은 객체를 참조 중이므로, ==연산자를 사용해도 같은 참조값이기 때문에 true 나옴

- 풀: 필요한 자원들을 모아놓은 곳
객체를 풀에 미리 만들어두고 필요할때마다 풀에서 꺼내 재사용 가능, 성능 & 메모리 절약
문자열 풀은 힙 영역 사용

- 여러 사람이 코드짜면 문자열을 객체로 선언했는지, 리터럴로 선언했는지 모르므로 그냥 equals() 쓰는게 나음

- String은 불변 객체이므로 변경이 필요할때는 기존 객체의 값 변경 대신 새로운 객체에 변경 결과를 반환받아 새로 담을 것

- String이 불변 객체인 이유: String 내부값을 변경할 수 있으면 기존 문자열 풀에서 같은 문자를 참조하는 변수들의 모든 문자가 함께 변경되어 버리는 문제가 발생한다(사이드 이펙트)

- a.equals(b): 문자열 a와 b가 같은지 비교(논리적으로) 

- String 단점: 여러개의 문자열을 더할때 중간에 생성된 객체는 쓰이지 않고 최종 결과의 객체만 쓰임
-> 해결책: 가변 String을 쓴다: StringBuilder(사이드이펙트 주의)

- StringBuilder는 문자열을 변경하는 동안만 사용하다가 문자열 변경이 끝나면 불변으로변환하는 것이 좋다.

- 자바 자체 최적화 어려울때: 반복문으로 문자열 객체를 여러개 생성해야할때 -> 반복횟수만큼 새 객체 계속 생겨서 낭비
-> 해결책: 문자열을 가변 객체로 생성하면 새 객체 안생겨서 시간 + 메모리 절약

- StringBuilder를 직접 사용하는 것이 더 좋은 경우
1. 반복문에서 반복해서 문자를 연결할 때
2. 조건문을 통해 동적으로 문자열을 조합할 때
3. 복잡한 문자열의 특정 부분을 변경해야 할 때
4. 매우 긴 대용량 문자열을 다룰 때

- 메서드 체이닝: 메서드가 체인처럼 '.' 으로 쭉 연결된 것
메서드 체이닝 방식은 메서드가 끝나는 시점에 바로 '.' 을 찍어서 변수명을 생략할 수 있음
메서드 체이닝이 가능한 이유는 메서드가 자기 자신의 참조값을 반환하기 때문임
따라서 참조값에 '.' 을 찍어서 바로 자신의 메서드를 호출 가능





- 기본형 데이터의 한계
1. 객체가 아니어서 메서드 호출 불가
2. null 값을 가질수 없고 반드시 특정 값을 가져야 함

- 래퍼 클래스: 특정 기본형을 감싸서 클래스 형태로 만든(단점 극복을 위해) 클래스

- 자바는 기본형에 대응하는 래퍼 클래스들을 기본으로 제공함
클래스들은 불변이므로 equals() 메서드로 비교해야 함

- 박싱: 기본형을 래퍼 클래스로 제공하는 것
객체 만들때 new Integer(10)으로 만들지 말고 Integer.valueOf(10)으로 만들것 -> 내부에서 new Integer(10)을 통해 객체를 만들어줌

- 자주 사용하는 숫자(-128 ~ 127)는 내부에서 미리 Integer 객체로 만들어둠(문자열 풀과 비슷)

- 언박싱: 래퍼 클래스에 들어있는 값을 다시 꺼내는 메서드를 의미

박싱/언박싱 예시

int value = 7;
// 박싱
Integer boxedValue = Integer.valueOf(value); -> 박싱(int -> Integer)할때는 valueOf() 사용

// 언박싱
int unboxedValue = boxedValue.intValue(); -> 언박싱(Integer -> int)할때는 intValue() 사용

- 오토 박싱/언박싱: 위 과정을 자동으로 해주는 기능 

-> Integer boxedValue = value;
    int unboxedValue = boxedValue; 가 가능함

- 래퍼 클래스 주요 메서드
valueOf(): 래퍼 타입을 반환(숫자, 문자열 모두 지원)

parse기본형(): 문자열을 기본형으로 변환
-> 기본형에 따라 종류가 다름(parseInt, parseDouble, parseLong 등등)

compareTo(): 내 값(객체)와 매개변수로 넘어온 값을 비교. 내 값이 크면 1, 같으면 0, 내 값이 작으면 -1을 반환

Integer.sum(), Integer.min(), Integer.max(): static메서드. 덧셈, 작은 값 큰 값 연산을 수행

- 래퍼 클래스는 기본형보다 메모리를 많이 쓰고 연산 시간도 오래걸림 -> 적절히 최적화할것


- Class 클래스: 특정 클래스의 정보를 얻음
ex) 
타입 정보 조회: 클래스 이름, 부모클래스, 인터페이스, 접근 제한자 등
리플렉션: 클래스 속성/기능/생성자 조회를 통한 객체 생성 및 메서드 호출
동적 로딩/생성: 동적 클래스 로드, newInstance() 메서드를 이용한 새 객체 생성
애노테이션 처리: 클래스 적용 애노테이션(오버라이딩) 조회 및 처리

- Math 클래스: 수학연산 도와주는 클래스
- Random: 난수 생성 클래스


- 열거형 이전 문제점: 코드에서 정해놓은 특정 문자열이 있는데 사용자가 그와 똑같이 입력하지 않는 경우
-> 열거형으로 해결

자바 열거형 쓰는법
1. 회원등급 클래스 선언후 회원 등급별 상수(static, final)를 별도의 객체로 선언 
2. 클래스에 귀속되면서 상수인, 서로 다른 참조값 가진 객체 생성 
3. 만든 객체를 인수로써 사용

문제: 외부에서 클래스의 인스턴스 멋대로 생성 가능
해결: 생성자만 private으로 선언(상수는 main 메서드에서 이용함) -> 내부에서 생성한 상수만 이용 가능

장점
1. 잘못된값 입력 방지(문자열 형태 아님)
2. 정해진 객체만 사용 가능하므로 일관성 보장

단점: 코드 줄이 길어짐
해결: 자바 지원 열거형 쓰기

- 열거형 특징
1. 열거형도 클래스임(java.lang.Enum 상속 받음)
-> 이미 상속받은 클래스 하나 있으므로, 다른 클래스 상속 못받음
2. 외부에서 상수 임의 생성 불가 -> 클래스 내부에서 미리 선언해야 함
3. 등급별 다중 if문 대신 switch문도 사용 가능
4. 인터페이스 구현 가능
5. 추상 메서드 구현 가능

- 열거 클래스 주요 메서드
values(): 모든 ENUM 상수 포함하는 배열 반환

valueOf(String name): 매개변수와 일치하는(문자열과 비교) ENUM 상수를 반환

name(): ENUM 상수 이름을 문자열로 반환

ordinal(): ENUM 상수의 선언 순서(0부터 시작)를 반환
-> 등급 중간에 추가되면 등급별 값이 변경돼서 가급적 사용 자제

toString(): ENUM 상수의 이름을 문자열로 반환
name()메서드와 유사하지만 toString()은 직접 오버라이드 가능


리펙토링1: 열거 클래스 내부에 할인율 속성 추가(불변) 
-> 사용자 정의 생성자로 상수 생성 할때 등급별 할인율 정해짐(생성자가 매개변수 받아서)

리펙토링2: 클래스를 열거형으로 자체 선언 
-> 생성자에 기본적으로 private 있어서 따로 못붙임(상수 지정할때만 생성자 쓰임) 
-> BASIC(10) 이런식으로 선언하면 알아서 받음
+ 값 조회 전용 게터(getter) 선언

리펙토링3: discountService 클래스의 할인율 구하는 discount 메서드를 열거 클래스로 옮기기
-> 자체적으로 할인율 계산 가능

리펙토링4: discountService 클래스 제거
-> 열거 클래스 자체에서 discount 메서드 호출하도록 변경

리펙토링5: main 메서드 부분 중복 제거
-> 열거형 배열 선언해서 열거 클래스 모든 속성 배열에 담기
-> 등급별 할인금액 출력가능한 메서드 선언 
-> for문 돌리면서 위 메서드 쓰기


- Period: 두 날짜 사이 간격
- Duration: 두 시간 사이 간격

- LocalDate: 날짜만 표현
- LocalTime: 시간만 표현
- LocalDateTime: 날짜/시간 둘다 표현

- 모든 날짜 클래스는 불변 클래스임
-> 생성한 객체 반환값(참조값) 무조건 받아야함(안받으면 왜만듦?) 까먹지말고 꼭 참조할것

- now(): 현재의 날짜/시각/타임존 객체를 반환

- of(): 사용자가 입력한 년, 월, 일/시, 분, 초 객체를 반환
-> 타임존만 ZonedDateTime.of()로 직접 타임존을 넣어줘야 함

- plusXxx(): 사용자가 입력한 값만큼 년, 월, 일/시, 분, 초 중 하나를 더할 수 있음

- toXxx(): 날짜/시각 분리한 객체를 반환

- LocalDateTime.of(localDate, localTime): 날짜 시간 합친 객체를 반환

- isBefore(): 호출객체의 날짜/시간이 매개변수보다 이전이면 true를 반환

- isAfter(): 호출객체의 날짜/시간이 매개변수보다 이후면 true를 반환

- isEqual(): 호출객체의 날짜/시간이 매개변수와 같으면 true를 반환
-> isEqual()은 시간만 비교, equals()는 타임존(서울 시간, 태평양 시간)까지 비교함

- 타임존: 각 지역별 시간이 존재하는 것
-> ZoneId 클래스가 타임존 제공

- ZoneId.systemDefault(): 내 PC가 속한 타임존 객체 반환

- ZoneId.of(): 사용자가 제공한 타임존을 ZoneId 객체로 반환

- ZonedDateTime: LocalDateTime에 ZoneId가 합쳐진 것
-> 날짜, 시각, 타임존을 순서대로 보여줌

- OffsetDateTime: LocalDateTime에 UTC 오프셋 정보인 ZoneOffset이 합쳐진 것
- UTC 오프셋: 특정 지역의 현재 시간이 UTC(세계표준시)를 기준으로 몇시간 차이인지 나타내는 시간의 차이


- Instant: UTC를 기준으로 한, 시간의 특정 지점
-> 날짜 시간을 나노초를 기준으로 표시한다(즉 초 데이터만 들어있음)
-> UTC가 기준이므로 명확성이 있음


- Period 클래스: 날짜 사이 간격을 년, 월, 일로 표시
-> 계산에 사용 가능, 간격 차이를 통해 특정 날짜 유추 가능

- Duration 클래스: 시각 사이 간격을 시, 분, 초로 표시
-> 계산에 사용 가능, 간격 차이를 통해 특정 시간 유추 가능


- TemporalAccessor 인터페이스: 날짜와 시간을 읽기 위한 기본 인터페이스

- Temporal 인터페이스: TemporalAccessor의 하위 인터페이스로, 날짜와 시간을 조작(추가, 빼기 등)하기 위한 기능 제공함 
-> 날짜/시간을 변경, 조정 가능

-> TemporalAccessor는 읽기 전용 접근, Temporal은 읽기와 쓰기(조작) 모두를 지원

- TemporalAmount 인터페이스: 시간의 간격(시간의 양, 기간)을 나타내며, 날짜와 시간 객체에 적용하여 그 객체를 조정(더하기 빼기) 가능

- TemporalUnit, ChronoUnit: 시간의 단위(열거형) ex) 1일, 1달, 1년 등 -> 정확히는 시간의 양
-> TemporalUnit은 인터페이스, ChronoUnit은 인터페이스를 구현한 열거 클래스

- TemporalField, ChronoField: 날짜, 시간을 나타내는 데 사용되는 열거형
-> YEAR, MONTH_OF_YEAR, DAY_OF_MONTH 등의 속성 존재

- Temporal.with(): 날짜/시간의 특정 필드만 변경한 값을 담은 새로운 객체를 반환
-> 불변객체이므로 반환값 받을것

- TemporalAdjuster: 복잡한 날짜 계산 가능(다음 금요일, 이번달 마지막 금요일 등) 

- DayOfWeek: 요일 나타내는 열거형

- 포맷팅: 날짜와 시간 데이터를 원하는 포맷의 문자열로 변경하는 것
ex) Date -> String(ofPattern 메서드로 원하는 포맷 지정 가능)
- 파싱: 문자열을 날짜와 시간 데이터로 변경하는 것
ex) String -> Date(parse 메서드) -> 이것도 포맷 지정 가능

- 문자열 읽어서 날짜/시간으로 파싱할 때, 년/월/일/시/분/초의 위치를 정해서 읽어야 함
-> yyyy-MM-dd HH:mm:ss 방식



- 중첩 클래스: 클래스가 여러개 중첩된 것

- 종류
1. 내부 클래스 아닌것: 정적 중첩 클래스
2. 내부 클래스인것: 내부 클래스, 지역 클래스, 익명 클래스

- 중첩/내부의 차이: 
중첩은 클래스 안에 존재만 하고 클래스에 속한것은 아닌 것
내부는 클래스 안에 존재하면서 동시에 클래스에 속한 것

- 중첩 클래스 왜만듦?
특정 클래스가 다른 하나의 클래스 안에서만 사용되는 경우, 두 클래스가 서로 연관이 깊은 경우
-> 하나를 다른 하나 안에 넣어버리면 그룹화, 캡슐화가 가능해서 쓰는것 그거말곤 없음

- 정적 중첩 클래스: 클래스가 다른 클래스에 static으로만 들어간 것(서로 다른 클래스라 봐도 무방)
-> 바깥 클래스 객체에 접근 불가, static인 바깥 클래스 멤버에 접근 가능(클래스 안에 있으므로 private static 멤버에도 접근 가능)
-> new 바깥클래스.중첩클래스()로 중첩클래스의 객체 생성 가능

바깥 클래스가 아닌 다른 클래스에서 중첩 클래스를 불러올수 있지만(바깥클래스.중첩클래스()) 그럴땐 그냥 밖으로 빼는게 나음

- 내부 클래스: 클래스가 다른 클래스에 한 요소로써 포함된 것
-> 바깥 클래스 멤버에 접근 가능, static도 접근 가능, 같은 클래스이므로 private 멤버에도 접근 가능

- 내부 클래스는 바깥 클래스의 인스턴스에 소속돼야함
따라서 내부 클래스를 생성할 때 속한 클래스의 인스턴스 참조가 필요
ex) 바깥클래스.new 내부클래스() -> 속한 클래스 내부에 내부 클래스가 생성
-> 바깥 클래스 객체를 먼저 만들고 안에 만들어야함
-> 실제로는 안에 있는 클래스가 바깥 클래스의 참조를 보관하여 언제든 바깥 클래스에 접근 가능한 방식

- 바깥 클래스의 인스턴스 변수 이름과 내부 클래스의 인스턴스 변수 이름이 같으면 어떻게 될까?
-> 지역변수, 내부 클래스 변수, 바깥 클래스 변수 순으로 우선도 부여
-> 애초에 이름 다르게 하기


- 지역 클래스는 내부 클래스의 특수 케이스: 코드 블럭 안에서 선언함(바깥 클래스의 메서드 같은거 안에서 선언 가능)
-> 내부 클래스 지역변수 접근 가능, 자신이 속한 코드블럭 매개변수 접근 가능 
-> 접근 제어자 사용 불가능


- 변수 캡쳐: 지역 클래스의 인스턴스를 생성하는 시점에, 필요한 지역 변수를 복사해서 생성한 인스턴스에 함께 넣어두는 것


지역 변수 캡쳐 과정
1. 지역 클래스의 객체 생성할 때 지역 클래스가 접근하는 지역 변수를 컴파일러에서 확인
2. 지역 클래스가 사용하는 지역 변수가 있으면 복사함(매개변수도 지역변수이므로 복사함)
3. 복사한 지역 변수를 지역 클래스 객체에 포함한다
4. 복사한 지역 변수를 객체를 통해 접근 가능

-> 원래 지역변수는 그 변수가 속한 메서드가 종료되면 같이 사라지고, 
클래스는 지역변수보다 생명주기가 길어서 나중엔 클래스만 남을수밖에 없는데,
이때 자바의 지역변수 캡쳐 기능을 이용해서 지역 변수를 아예 복사해서 지역 클래스 객체에 같이 넣을 수 있다(필드값처럼)
따라서 원본 지역변수가 사라져도 지역변수를 계속 이용할 수 있다.
-> 바깥 클래스의 메서드 안에 속한 지역 클래스가 있을때 그 지역 클래스가 속한 메서드의 변수들은 모두 지역 변수여서(매개변수 포함) 스택에 메서드랑 같이 쌓이다가 종료되고
지역 클래스는 힙 영역에 들어갔다가 나중에 사라져서 지역변수보다 생명주기가 김  

- 지역 클래스가 접근하는 지역 변수는 불변이어야 한다
따라서 final로 선언하거나 사실상 final이어야 한다

사실상 final이라는 뜻은 지역변수를 초기화하고 값을 한번도 변경하지 않은 것을 의미한다

지역변수 값을 변경하면 복사한 값과 원본 값이 서로 달라질수 있어서 문제가 생기고 이 외에도 많은 문제가 생겨서 못 변경하게 막는것


익명 클래스: 이름이 없는 지역 클래스
-> new 다음에 바로 상속받아 구현할 부모 클래스 타입을 입력하고 그 밑에 클래스 정의부를 바로 씀
-> 부모 클래스의 인터페이스를 실제로 구현하는데, 이름은 없는 클래스


익명 클래스 특징
1. 이름 없는 지역 클래스를 선언한 동시에 생성됨
2. 반드시 부모 클래스를 상속받거나 인터페이스를 구현해야함. 즉 익명 클래스를 생성할 때는 상속받을 부모 클래스나 구현할 인터페이스가 필요함
3. 익명 클래스는 이름 자체가 없으므로 생성자도 없음
-> 익명클래스 객체 만들때 부모 클래스/인터페이스의 기본 생성자를 불러와 생성함
-> 또한 익명클래스 객체를 선언할 때 익명클래스는 이름이 없으므로, 익명클래스 객체를 생성할때마다 정의부를 일일히 다 적어줘야함
4. AnonymousOuter$1처럼 바깥 클래스 이름 + $ + 숫자로 정의됨. 익명 클래스가 여러 개면 $1, $2, $3 으로 숫자가 익명 클래스의 개수만큼 늘어나면서 익명 클래스들을 구분할 수 있게 됨

익명 클래스는 클래스 당 단 하나의 객체만 만드는게 가급적 좋음
-> 객체 하나 더 만들려면 다시 정의부를 쓰고 정의해야함(익명 클래스는 이름이 없으므로 객체를 만들때마다 일일히 정의부를 붙여서 만들어줘야함) 
이는 익명 클래스로 여러 객체를 만드는것이 불편함을 의미함
부모 클래스나 인터페이스의 이름으로 객체를 여러 개 만들거라면 익명 대신 지역 클래스로 선언해야함

사용처: 지역 클래스가 일회용으로만 쓰이거나 간단한 구현할때 씀


지역 클래스 이용한 리펙토링:
- 변하지 않는 부분과 변하는 부분을 따로 분리하기
- 타입에 따라 변하는 부분을 각각 다른 지역 클래스로 선언해서 main 메서드에 넣기 
- 과정을 실제로 수행하는 메서드를 가진 인터페이스를 하나 만든후 그 메서드(정의만함)가 지역 클래스 객체를 매개변수로 받도록 설정하기
-> 어떤 타입의 객체가 오는지에 따라 다른 내용의 메서드가 호출됨(오버라이딩 구현)

-> 클래스 타입에 따라 오버라이딩 내용이 다른 것과 익명 클래스에서 여러 객체를 만들려면 정의를 일일히 새로 해야 한다는 점을 이용: 익명 클래스에서 객체를 만들때마다, 인터페이스의 메서드를 오버라이딩하여 구현한 내용을 새로 정의해주기

-> 익명 클래스 객체를 만들때 변수 이름을 만들어서 객체 참조값을 복사해주는 대신, 객체 자체를 메서드 인수로 바로 전달할 수 있음
이때 인수로 익명 클래스 객체가 들어가고, 익명 클래스 객체는 생성할때마다 정의부를 써줘야 하므로, 메서드의 인수로 익명 클래스 객체가 들어간 다음 그 객체의 정의부도 같이 메서드의 괄호() 안에 들어가게 됨

기존엔 메서드 인자로 기본형이나 참조형만 전달할 수 있었음
-> 람다: 메서드 인자로 또 다른 메서드를 통째로 전달할 수 있게 해주는 것

형식: 매개변수 -> {실행문}

어떤 메서드에 전달할 매개변수가 없고 ()만 있다면, 람다식에서도 매개변수 자리에 ()만 넣을 수 있음(어차피 매개변수 전달할 메서드가 매개변수 안받으니까 상관없음)



예외 처리: 프로그램 실행 중 발생 가능한 예외상황을 처리하기 위한 메커니즘을 제공함 
이는 프로그램의 안정성과 신뢰성을 높이는 데 중요한 역할을 함

try, catch, finally, throw, throws 다음의 5가지 키워드 사용

예외 처리 과정
1. Main 은 Service 를 호출
2. Service 는 Client 를 호출
3. Client 에서 예외가 발생
4. Client 에서 예외를 처리하지 못하고 밖으로 내보냄 
여기서 Client의 밖은 Client 를 호출한 Service 를 의미
5. Service에 예외가 전달되고 Service 에서 예외를 처리함
이후 애플리케이션 로직이 정상 흐름으로 동작
6. 정상 흐름을 반환

예외를 처리하지 못하는 경우, 자신을 호출한 곳으로 예외를 보냄

예외 규칙
1. 예외는 처리하거나 밖(자기 호출한 곳)으로 내보내야 함
2. 예외를 내보낼때 지정 예외뿐 아니라 그 예외의 하위 예외들도 같이 처리 가능함

main에서도 예외 처리 못하면 예외 로그 출력하고 시스템 종료


예외 클래스 종류

1. Throwable : 최상위 예외 
하위에 Exception 과 Error 있음
2. Error: 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구가 불가능한 시스템 예외 
개발자는 이 예외 잡을필요 X
1. Exception: 체크 예외
애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외 -> 개발자가 체크해야할 예외
Exception과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. 단 RuntimeException 은 예
외로 한다(언체크 예외)
1. RuntimeException: 언체크 예외, 런타임 예외
컴파일러가 체크 하지 않는 언체크 예외
RuntimeException과 그 자식 예외는 모두 언체크 예외임
RuntimeException의 이름을 따라서 RuntimeException 과 그 하위 언체크 예외를 런타임 예외라고도 함

체크 예외: 개발자가 발생한 예외를 명시적으로 처리해 줘야 함(안하면 오류)
언체크 예외: 개발자가 발생한 예외를 명시적으로 처리 안해도 됨

예외 클래스 만들려면 Exception 클래스 상속하면 됨


예외 클래스 선언: 새로운 클래스를 만들고 그 클래스가 Exception 클래스를 상속받게 하면 그 클래스는 예외 클래스가 됨
-> Exception 받으면 체크 예외가 됨
-> RuntimeException 상속받으면 언체크 예외 됨

throw: 새로운 예외 생성 키워드
throw도 객체로 분류되므로 new 로 객체 생성후 예외 발생시켜야 함

throws: 발생시킨 예외를 메서드 밖으로 내보낼때 사용하는 키워드
-> throw, throws 헷갈리지 말것


try ~ catch()문: try에서 예외를 잡아 catch 로 넘김
만약 try에서 잡은 예외가 catch 의 대상에 없으면 try가 예외를 잡을 수 없음 이때는 예외를 밖으로 내보내야 함

catch에 예외를 지정하면 해당 예외와 그 하위 예외를 모두 잡아줌

예외도 객체여서 다형성이 적용됨

체크 예외 정리: 현재 메서드에서 잡아서 처리하거나, 처리못하면 자기 호출한 메서드로 보내기
잡는것은 try ~ catch()로 잡아서 처리하고
내보내는것은 throws를 지정해서 예외를 내보냄

체크 예외 장점
- 컴파일러에서 예외를 잡아서 알려주는 안전장치 느낌(안전성 높음)
단점
- 개발자가 모든 예외를 체크해서 처리해야 하므로 번거로움(귀찮음)

언체크 예외: RuntimeException - 컴파일러가 예외를 체크하지 않음
예외를 던지는 throws를 선언하지 않고 생략 가능함
생략하면 자동으로 예외를 던짐

체크 예외: 예외를 잡아서 처리하지 않으면(즉 예외를 던질거라면) 항상 throws 키워드를 사용해서 던지는 예외를 직접 선언해야 한다.
언체크 예외: 예외를 잡아서 처리하지 않아도 throws 키워드를 생략할 수 있다(자동으로 예외 던져줌)
물론 필요한 경우 예외를 잡아서 처리 가능함

언체크 예외 장점
- 사소한 예외는 잡을필요 없음 -> 개발자가 알아서 수정
단점
- 개발자가 실수로 중요한 예외를 누락할 수 있는 가능성이 있음


다시 정리

체크 예외: Exception 사용, 예외를 잡아서 직접 처리하거나 처리 못하면 자신을 호출한 메서드로 예외를 보내거나 둘중 하나임
예외를 보낼때는 예외에 throws(throw와 헷갈리지 말것. throw는 새로운 예외를 생성하는 키워드임) 키워드를 선언해서 보내고, 예외를 잡을때는 try ~ catch()문을 통해 catch에 지정한 기준에 적합한 예외를 잡아서 처리함

사용자가 예외를 명시적으로 처리해줘야 해서 번거롭지만, 예외에 대한 메세지를 컴파일러에서 알려주기 때문에 안전성은 높음

언체크 예외: RuntimeException 사용, 
예외를 잡아도 되고 안잡아도 되고 
예외를 자신을 호출한 메서드에 명시적으로 보내지 않아도 됨(컴파일러에서 자동으로 보내줌)
내보낼때도 예외에 throws 안붙여주고 생략해도 됨

사소한 예외는 생략할 수 있어서 비교적 편하고 자유도가 높지만
사용자가 실수로 중요한 예외를 누락할 수 있어서 사용할거면 제대로 사용해야 함



문제: 정상흐름, 예외흐름이 섞여있어서 코드 가독성이 떨어짐
예외흐름의 코드 분량이 너무 많음



try: 정상 흐름
catch: 예외 흐름
finally: 어떤 경우에도 반드시 호출돼야 하는 마무리 흐름

try구문이 시작되면 finally 구문은 반드시 호출됨
정상 흐름 -> finally
예외 catch -> finally
예외 던짐 -> finally

NetworkClientExceptionV3: NetworkClient 에서 발생하는 모든 예외 클래스들의 부모 클래스
ConnectExceptionV3 : 연결 실패시 발생하는 예외. 내부에 연결을 시도한 address 를 보관함
SendExceptionV3 : 전송 실패시 발생하는 예외. 내부에 전송을 시도한 데이터인 sendData 를 보관함


자바에서 예외는 객체이므로 부모 예외를 잡거나 던지면 자식 예외도 함께 잡거나 던질 수 있음 
예를 들어 NetworkClientExceptionV3 예외를 잡으면 그 하위의 예외 클래스인 ConnectExceptionV3, SendExceptionV3 예외도 함께 잡을 수 있다.
특정 예외를 잡아서 처리하고 싶으면 ConnectExceptionV3, SendExceptionV3 와 같은 하위 예외를 잡아서 처리하면 된다.

-> 예외 상황들을 예외 클래스로 정의해서 객체적으로 구분하기

예외 상황이 너무 많아서 사용자가 잡아내지 못하는 예외가 존재한다면?
-> 내가 알고있는 자식 예외들은 미리 catch로 잡아놓고 부모 예외는 밑으로 놓기(부모 예외를 위에 놓으면 위에서 다 걸리므로 밑에 놔야함)
-> 모든 예외를 잡아서 처리하려면 맨 마지막 catch문에 Exception 놓으면 다 잡기 가능

or 연산자 '|'를 이용해 여러 예외를 한번에 잡을 수 있음

추가: 실무에서 처리 못하는 예외 발생하면 고객한테 오류가 발생했다고만 알려주고 로그 기록해놓기


발생하는 예외가 너무 많으면 throws Exception으로 모든 예외를 던져버릴수도 있지만 큰 문제가 생김
-> 모든 예외를 Exception의 이름으로 다 던져버리기 때문에 개발자는 메세지 이름을 Exception으로만 받게 되고,
정확히 무슨 예외인지 알 수 없게 됨
-> throws Exception 사용하지 말것

언체크 예외: 최상위 예외 클래스가 언체크 예외인 RuntimeException 클래스를 상속받게 하면,
그 예외 클래스의 자식 클래스들은 모두 언체크 예외가 됨

외부 자원: 프로그램이 컴퓨터 바깥에 있는 시스템이나 장치, 데이터 등과 연결해서 사용하는 자원(데이터 등)

애플리케이션 등에서 외부 자원을 사용하는 경우 반드시 외부 자원을 해제해야 함

Try with resources: 원래 외부 자원을 반납하던 finally 대신 try 에서 외부자원을 함께 사용한다는 뜻
-> AutoCloseable 클래스 선언 후, 

try (Resource resource = new Resource()) 
{
    // 리소스를 사용하는 코드
}
구문 사용

-> try 끝나는 시점에 close() 메서드 자동 호출됨
-> close()를 오버라이딩 해서 외부자원 반납 방법을 사용자가 정의할 수도 있음

장점
- finally 안적거나 그 안에서 자원해제하는 코드 누락되는 문제 사전에 방지 가능
- 코드가 간결해지고 가독성 향상됨
- 외부자원이 try 블록 안에서만 쓰이기 때문에 사용 범위가 줄어 코드 사용이 편리함(다른 코드와의 연결이 없으므로)
- 기존엔 try-catch-finally 순으로 진행하고 finally에서 자원을 반납했다면, 
Try with resources구문에서는 try블록이 끝나면 자동으로(close) 외부 자원을 바로 해제하기 때문에 해제 시간이 빠름