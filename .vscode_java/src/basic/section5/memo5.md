# this를 사용하는 이유
메서드 안에서는 클래스의 멤버변수보다 메서드 안의 매개변수가 더 우선도가 높기 때문에, 
this를 사용하지 않으면 클래스의 멤버 변수를 메서드 안에서 사용할 수 없다.

이를 해결하기 위해 this를 사용하여 내가 클래스 내부 멤버변수로써 사용하고 싶은 데이터 앞에 this를 붙이면 이 데이터는 객체 자신의 참조값을 가리키게 된다.

정리: 멤버 변수와 메서드 매개변수의 이름이 같을때는 멤버 변수로 사용하고 싶은 데이터 이름 앞에 this를 붙여서 구분할 수 있다. <br>
또는 애초에 멤버변수와 매개변수 이름을 서로 다르게 하여 헷갈리는 일을 사전에 방지하는 방법도 있다. 


# 생성자
생성자는 객체가 생성될 때 자동으로 호출되어 객체의 초기 상태(디폴트값)을 설정하는 메서드 중 하나이다.

생성자는 사용자가 정의하지 않으면 컴파일러에서 기본 생성자를 자동으로 추가해주고, 기본 생성자는 새로 만든 객체의 멤버 변수에 기본 생성자가 정한 디폴트값을 부여받는다(예를들면 int의 디폴트값은 0, String의 디폴트값은 null).

우리가 여태까지 써왔던 <br>

```Data data = new Data();```

역시도, 사용자가 직접 만든 생성자가 없었으므로 컴파일러에서 주는 기본 생성자가 사용된 모습이다(new로 객체를 위한 메모리 공간을 할당해주고 그 객체의 디폴트값을 기본 생성자 Dat()가 정해주는 모습).

만약 사용자가 특정 매개변수를 받게 하는 사용자 정의 생성자를 최소한 하나라도 만들었다면, 기본 생성자는 사라지며 사용자는 새로운 객체를 만들 때 반드시 자신이 정의한 여러 개의 생성자 중 하나를 사용하여 새로운 객체의 디폴트 값을 정해줘야 한다.

또한 위에서 말한것처럼 생성자는 오버로딩(함수 이름은 같지만 받는 매개변수가 다른 것)이 가능하기 때문에 매개변수가 다른 여러 개의 생성자를 만들 수 있다.


# this()
생성자 오버로딩을 통해 여러 개의 생성자를 만들었을 때, 생성자의 코드가 중복되는 경우가 나타날 수 있다. 예를 들면,

```
public MemberConstruct(String name, int age) 
{
    this.name = name;
    this.age = age;
    this.grade = 50;
}

public MemberConstruct(String name, int age, int grade) 
{
    this.name = name;
    this.age = age;
    this.grade = grade;
}
```

이 두개의 생성자에서     
```
this.name = name;<br>
this.age = age; 
```
이 부분이 중복되어 효율이 떨어지는 문제가 생기는데, 이를 this()를 사용하여 해결할 수 있다.

받는 매개변수 개수가 더 적은 생성자 쪽의 코드를 this(name, age, 50)으로 바꾸면 this에 의해 생성자 내부에서 자신의 생성자가 호출된다.<br>
this가 자신의 참조값 가리키므로 가능한 기능이고, 받는 매개변수가 또 다른 생성자와 같은 3개이므로 그것과 대응되는 생성자가 대신 호출되어 객체의 멤버변수에 초기값을 부여해준다.   

또한 this()는 생성자 블록 안에서 가장 위에 써져야 한다. 그렇지 않으면 에러가 발생한다.