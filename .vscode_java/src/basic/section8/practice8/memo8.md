# 메모리 구조
1. 메서드: 클래스 정보, static 변수 등을 보관하는 공간. <br>
   클래스 정보는 곧 붕어빵 틀을 말하므로 클래스를 선언하면 그 클래스는 메서드 영역에 들어간다는 소리다.

2. 스택 영역: 실제 프로그램이 실행되는 공간.<br>
   메서드 하나를 실행할때마다 그 메서드가 스택에 하나씩 쌓이며, 메서드가 종료되면 그 메서드는 스택에서 빠져나온다. <br>
   따라서 스택은 후입선출(나중에 들어간 것이 먼저 나옴)구조이다.

   이때 메서드 안의 지역 변수들도 메서드와 같이 스택에 들어간다. 메서드가 종료되면 스택에서 빠져 나오면서 지역변수도 같이 사라지게 되는 것

3. 힙 영역: 실제 객체(인스턴스)가 생성되는 공간.<br>
   배열이나 객체 등이 선언될때, 힙 영역에 메모리가 할당된다.<br>

    ``` Data data = new Data(); ``` 에서 new가 힙 영역에 메모리를 할당해주는 키워드이다.

    또한 가비지 컬렉션이 활동하는 주요 공간이기도 하다.

# static
어떤 클래스를 하나 만들고 멤버 변수 count를 초기화 시켰다고 치자. 우리는 클래스의 객체를 만들어서 count를 3번 증가시켜서 count = 3이 되게 하고 싶다.

```
package static1;

public class Data1 
{
    public String name;
    public int count;

    public Data1(String name) 
    {
        this.name = name;
        count++;
    }
}
```

```
package static1;

public class DataCountMain1 
{
    public static void main(String[] args) 
    {
        Data1 data1 = new Data1("A");
        System.out.println("A count=" + data1.count);

        Data1 data2 = new Data1("B");
        System.out.println("B count=" + data2.count);

        Data1 data3 = new Data1("C");
        System.out.println("C count=" + data3.count);
    }
}
```

그래서 이런 코드들을 만들어서 실행했는데 

```
A count=1
B count=1
C count=1
``` 
이런 결과가 나와서 count는 3이 되지 않았다.

이 코드가 제대로 작동하지 않는 이유는 당연히도 서로다른 객체를 3개 만들면 서로다른 멤버 변수도 3개가 만들어지기 때문이다. 따라서 서로 다른 count만 1씩 증가하여 저런 결과가 나온것이다.

이를 해결하려면 클래스 자체에 귀속된 static이라는 키워드를 쓰면 된다.

static 키워드를 붙인 멤버 변수는 (클래스명.멤버 변수) 라는 방식을 통해 접근 가능하다.

static 키워드가 붙은 변수여도 클래스의 멤버인것은 변함이 없어 일반 멤버변수와 혼동할 수도 있어 구별이 필요하다.

static이 붙지 않은 변수는 인스턴스 변수라 하고, <br>
static이 붙은 변수는 클래스 변수, 정적 변수, static 변수 등으로 부른다.


# 변수의 생명주기

지역 변수(매개변수 포함): 지역 변수가 포함된 메서드가 종료되면 같이 소멸하므로 생명주기가 가장 짧다.

인스턴스 변수: 힙 영역에 클래스와 같이 할당되는 인스턴스 변수는 GC가 발동한 뒤로는 사라지기 때문에, 생명 주기가 지역 변수보다는 길지만 클래스 변수보다는 짧다.

클래스 변수: 클래스 자체에 귀속되는 클래스 변수는 메서드 영역에 클래스 정보와 같이 할당되는데, 자바 컴파일러가 시작될때 생겨나 자바 컴파일러가 종료되기 전까지 살아있기 때문에 생명주기가 가장 길다.

# 정적변수 접근 방식
정적변수에 접근하는 방식은 2가지가 있음

1. 인스턴스를 통한 접근
   
   인스턴스를 통한 접근은 별로 추천하지 않음 -> 컴파일러가 코드를 읽을때 객체의 멤버 변수에 접근하는 것으로 오해할 수 있기 때문

2. 클래스를 통한 접근
   
   애초에 static은 클래스 자체에 귀속되는 것이므로 static변수에 접근할때는 클래스로 접근하는게 나음


# static 메서드와 private 메서드 차이

1. 메서드가 외부로부터 받는 매개변수가 없고, 같은 클래스의 멤버변수들만 사용한 코드를 쓸때

-> 메서드를 private으로 선언하여 클래스 내부에서만 작동하게 만들 수 있음

2. 메서드가 외부로부터 받는 매개변수가 존재하고, 같은 클래스의 멤버변수들을 코드에 전혀 사용하지 않을 때

-> 메서드르 static으로 선언하여 외부에서 받은 값을 가공하는 용도로만 쓰이는, 클래스에 딱 하나만 존재하는 메서드로 만들자(내부 변수 사용도 안하는데 객체 만들때마다 새로운 메서드 계속 생기면 지저분해지므로).

static 키워드가 붙은 메서드는 정적 메서드 또는 클래스 메서드라 부를 수 있음<br>
static 키워드가 붙지 않은 메서드는 인스턴스 메서드라고 부름


# 정적 메서드 사용법
static 메서드는 static 멤버만 사용 가능함<br>
-> static 메서드는 클래스 자체 소속인데, 엄연히 구분되는 서로 다른 객체에 직접 접근할 수 없는게 당연한 사실<br>
-> static 메서드는 같이 static에 속한 정적변수나 메서드만 사용할 수 있다. 인스턴스 메서드나 변수는 사용 불가능함

하지만 반대 상황에서는 인스턴스 메서드가 정적 변수, 인스턴스 변수를 모두 사용 가능함
정적 메서드는 모든 객체가 공통으로 사용 가능하므로 모든 인스턴스에서 정적 변수, 메서드 등을 호출 가능함


## 정적 메서드가 인스턴스 변수, 메서드를 사용 불가한 이유
정적 메서드는 클래스를 통해 변수나 메서드를 다이렉트로 호출 가능해서 인스턴스처럼 참조 개념이 없음

참조값이 없는 메서드에서 참조값을 사용하려고 하니 당연히 에러가 뜨는 것

-> 정적 메서드의 매개변수로 인스턴스 변수를 받는다면 참조값이 정적 메서드에 전달되기 때문에 인스턴스 변수, 메서드 등의 사용이 가능하긴 함