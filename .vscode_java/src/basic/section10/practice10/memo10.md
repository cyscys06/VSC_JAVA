# 상속
어떤 클래스가 특정 클래스의 속성과 기능을 이어받아서 재사용할수 있게 하는 것.<br>
보통 추상적인 개념의 클래스를 하나 만들고, 그 클래스를 부모로 둔 후 추상 개념에서 나오는 구체적인 물체들에 대해 클래스를 각각 만들어서 부모 클래스의 속성, 기능을 상속받게 함

상속을 사용하려면 extends 키워드를 사용하고, 자식 클래스는 부모 클래스를 단 하나만 상속받을 수 있다.

추가) 클래스에 fianl을 붙여서 선언하면 상속이 불가능한 클래스가 된다

# 다이아몬드 문제
하나의 자식 클래스가 2개 이상의 부모 클래스를 상속받을 때, 여러 부모 클래스가 동일한 메서드를 갖고 있다면, 자식 클래스에서 그 메서드를 사용할 때 어떤 부모 클래스의 메서드를 사용할지에 대해 문제가 발생하게 됨. 그걸 다이아몬드 문제라고 함

-> 자바는 아예 하나의 자식 클래스가 동시에 여러 개의 부모 클래스를 상속받지 못하게 막아놓음

대신 인터페이스의 다중 구현을 통해 문제를 해결


# 클래스 상속: 메모리
부모 클래스를 상속하는 자식 클래스를 선언할 때 힙 영역에 자식 클래스 뿐만아니라 부모 클래스의 공간도 같이 할당됨. <br>
예를들어 a 클래스를 상속하는 b 클래스의 객체를 새로 만들면 힙 영역에 a, b 클래스가 모두 할당됨

단 부모 클래스와 자식 클래스는 서로 별개의 영역에 할당됨

메서드 c를 호출했다고 할때, b.c라는 방식으로 선언하게 될텐데 이때 컴파일러는 c 메서드가 어떤 클래스(부모 or 자식)의 메서드인지를 모름

이때 컴파일러는 **호출하는 변수의 타입(클래스)**를 우선으로 하여 선택함

b.c의 경우 c 메서드를 b 클래스에서 찾아 호출하게 됨

만약 b 클래스에 c 메서드에 없으면?<br>
b 클래스(자식 클래스)에 없으므로 부모 클래스로 올라가서 c 메서드가 있는지를 탐색함


# 상속 내용 정리
1. 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다(부모 자식은 서로 별개의 영역을 갖는다).
2. 상속 관계의 기능을 호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 메서드의 대상 타입을 찾는다.
3. 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생한다.


# 메서드 오버라이딩
부모 클래스에서 상속받은 속성이나 기능을 자식 클래스에게 적절하도록 약간의 수정을 하고싶다면?<br>
-> 메서드 오버라이딩을 통해 부모 클래스의 기능만을 수정할 수 있음(멤버 변수는 오버라이딩 안됨)

내가 부모 클래스에 있으면서 수정하고싶은 메서드가 있으면 ```@Override(애노테이션이라 부른다)``` 라고 표시하고, 수정한 부분을 자식 클래스에 적으면 동일한 메서드를 사용해도 자식 클래스에 있는 수정된 메서드가 호출된다.

애노테이션은 상위 클래스의 메서드를 오버라이드하는 것임을 나타낸다.

컴파일러는 애노테이션을 보고 이 메서드가 조건에 맞게 오버라이드 됐는지를 확인한다.<br>
이때 오버라이드가 잘못된 경우 애노테이션에 의해 컴파일 에러가 발생한다. 따라서 그냥 넘어갔을때 일어날 더 큰 문제를 사전에 방지해준다.

애노테이션은 코드의 명확성을 위해 붙여주는게 좋음

추가) final이 붙은 메서드는 오버라이딩이 불가능하다

# 메서드 오버라이딩 조건

1. 메서드 이름: 메서드 이름이 같아야 한다.
   
2. 메서드 매개변수(파라미터): 매개변수(파라미터) 타입, 순서, 개수가 같아야 한다.
   
3. 반환 타입: 반환형이 같아야 한다. 단 반환형이 하위 클래스 타입일 수 있다.
   
4. 접근 제어자: 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다. <br>
   예를 들어, 상위 클래스의 메서드가 `protected` 로 선언되어 있으면 하위 클래스에서 이를 `public` 또는`protected` 로 오버라이드할 수 있지만, `private` 또는 `default` 로 오버라이드 할 수 없다.

5. 예외: 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 `throws` 로 선언할 수 없다. <br>
   하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다. 예외를 학습해야 이해할 수 있다. 예외는 뒤에서 다룬다.

6. `static` , `final` , `private` : 키워드가 붙은 메서드는 오버라이딩 될 수 없다.<br>
`static` 은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미가 없다. 쉽게 이야기해서 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다.

7. `final` 메서드는 재정의를 금지한다(final 변수가 한번 초기화되면 바꿀수 없듯이).

8. `private` 메서드는 해당 클래스에서만 접근 가능하기 때문에 하위 클래스에서 보이지 않는다. 따라서 오버라이딩 할 수 없다.

9. 생성자 오버라이딩: 생성자는 오버라이딩 할 수 없다(즉 생성자는 자기 자신이 속한 클래스 안에서만 유일하게 존재 가능하다).
 


# super(부모 참조)
자식 클래스에 부모 클래스의 메서드로부터 오버라이딩된 메서드가 존재한다 쳣을때<br>
자식 클래스 말고 부모 클래스의 메서드를 호출하고 싶을때 super 키워드를 사용해 호출이 가능함(그냥 메서드 이름만 쓰면 자식 클래스의 오버라이딩된 메서드가 출력되므로)

자식 클래스와 부모 클래스에 동일한 값의 속성이나 기능이 있고 오버라이딩 됐더라도 super 키워드를 이용하면 자식 클래스의 속성, 메서드 뿐만 아니라 부모 클래스의 속성, 메서드도 불러올 수 있음 

-> 자식 클래스에서 부모 속성을 이용하는 등의 중복인 상황이 발생하면 super를 이용해 부모 클래스의 메서드를 불러와서 코드 길이를 단축할 수 있음

# 상속 생성자
상속 관계에서 부모의 생성자를 호출할때는 super()를 사용함