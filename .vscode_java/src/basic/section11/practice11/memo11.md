# 캐스팅
`(타입)` 처럼 괄호와 그 사이에 타입을 지정하면 참조 대상을 특정 타입으로 변경할 수 있다. 이렇게 특정 타입으로 변경하는 것을 캐스팅이라 함

부모 클래스가 자식 클래스 타입이 되면 다운캐스팅
자식 클래스가 부모 클래스 타입이 되면 업캐스팅


# 업캐스팅
```
Dog d = new Dog(); // Dog 타입에 Dog 메모리 참조값 할당(여기서 바로 Animal() 불러올려 하면 에러뜸. Animal 메모리가 Dog 타입에만 있는 멤버를 못받으므로. 또한 자식클래스 메모리를 할당하면 클래스 상속의 특성으로 부모 클래스의 멤버들은 자동으로 같이 딸려옴)
Animal a = (Animal) d; ((Animal)은 생략 가능) // d 변수가 갖고있는 Dog 메모리 참조값을 Animal 타입으로 바꿔서 Animal 타입에 할당
```

-> a의 타입은 Animal지만 Dog 타입인 메모리 참조값을 복사했음 
-> Dog(자식)의 메모리 참조값이 Animal(부모)형 변수에 복사됨 -> 자식이 부모로 갔으므로 업캐스팅

업캐스팅에서 Animal a = new Dog(); 가 가능한 이유: Animal과 Dog가 서로 상속관계이므로 업캐스팅을 통해 자식 클래스의 메모리를 부모 클래스에 할당하는게 가능해지기 때문 

이 코드는 업캐스팅을 단축한 것:

```
Parent poly = new Child(); // 자식 클래스 메모리를 부모 클래스에 다이렉트로 할당
```

# 다운캐스팅
```
Animal a = new Dog(); // Animal 타입 a에 Dog 메모리의 참조값을 복사(자식클래스 메모리 복사하면, 자식클래스에 상속받은 부모클래스 멤버랑 원래 자식이 갖고있던 멤버가 다 있어서, 자식클래스로 타입변경할때 미리 그 클래스의 메모리를 할당해놓는것)
Dog d = (Dog) a; // a가 갖고있는 Animal형의 참조값을 잠깐 Dog로 변경
```
Animal 타입에 Dog 메모리를 할당 못하는 이유: Dog 타입만 갖고있는 속성이나 메서드가 있을텐데, Animal에는 그런 메서드가 없으므로(부모 클래스 메모리를 불러온다고 해서 자식 클래스의 멤버가 같이 딸려오는게 아니므로) Dog에만 있는 멤버들을 인식할 수 없어서 오류 발생함

# 일시적 다운캐스팅 
부모가 자식 기능을 적은 횟수로 사용하려 할때 임시적으로만 타입을 변경이 가능
((Child) poly).childMethod(); childMethod라는 메서드를 호출할 때만 타입이 변경됨



# instanceof
어떤 변수가 참조하고 있는 인스턴스의 타입을 확인할때 사용

```
ex)
parent instanceof Child -> true or false
```
이 식은 조건식이므로 반환값이 bool형임
`instanceof` 키워드는 오른쪽 대상(Parent)의 자식 타입(Child)을 왼쪽에서 참조하는 경우에도 `true` 를 반환

즉 Parent가 자식 타입인Child()를 참조하는 경우도 true임

쉽게 이야기해서 오른쪽에 있는 타입에 왼쪽에 있는 인스턴스의 타입이 부모 자식 관계 상 들어갈 수 있는지 대입해보면 된다

자바 16부터는 `instanceof` 를 사용하면서 동시에 변수를 선언할 수 있다.

```
ex)
private static void call(Parent parent) 
{
    parent.parentMethod();
    //Child 인스턴스인 경우 childMethod() 실행
    if (parent instanceof Child child) 
    {
        System.out.println("Child 인스턴스 맞음");
        child.childMethod();
    }   
}
```
Child 타입 변수 child가 조건식 안에서 선언됐고, 조건식이 true이므로 child의 메서드를 선언하자마자 바로 실행 가능함



# 추상 클래스
기존 클래스와 똑같이 기능하지만, new를 통한 직접적인 인스턴스 생성은 불가능한 클래스
클래스를 선언할때 앞에 abstract를 붙여주기

# 추상 메서드 
메서드를 선언할때 앞에 abstract를 붙여주면 추상 메서드
추상 메서드가 하나라도 있는 클래스는 반드시 추상 클래스로 선언해야 함

추상 메서드는 메서드 바디(정의 부분)이 없어서 자식 클래스에서 반드시 오버라이딩 해야함(안하면 컴파일 에러)

# 추상 클래스 장점
1. 추상 클래스를 생성하면 부모 클래스에서 필요없는 인스턴스를 생성해야 했던 문제를 해결해준다(추상 클래스는 인스턴스를 생성 못하므로) 
2. 자식 클래스의 메서드를 깜박하고 오버라이딩하지 않는 문제도 해결한다(추상 메서드는 자식 클래스에서 반드시 오버라이드 해줘야 하므로)



# 인터페이스
순수 추상 클래스에서 class 키워드 대신 사용 가능한 키워드

## 순수 추상 클래스(인터페이스) 특징
1. 인스턴스 생성 불가
2. 상속 시 자식 클래스에서 모든 메서드 오버라이딩 필요
3. 다형성이 목적
4. 인터페이스 메서드는 모두 public, abstract으로 자동 선언(생략도 가능하며 권장함)
5. 다중 상속을 지원
6. 인터페이스에서 선언한 멤버 변수는 public, static, final이 모두 포함된걸로 침


# 인터페이스 상속
인터페이스를 상속 받을 때는 `extends` 대신에 `implements` 라는 '구현'이라는 키워드를 사용해야 한다. 인터페이스는 그래서 상속이라 하지 않고 구현이라 한다(부모 클래스에 추상적으로만 있던 메서드를 자식 클래스에서 구체적으로 오버라이딩하기 때문에 구현한다는 표현을 씀).   

# 다이아몬드 문제
인터페이스인 두 클래스를 하나의 자식 클래스가 모두 상속한다고 가정
인터페이스에서는 부모 클래스가 메서드를 추상화만 해놓고 직접 정의는 안한 상태임
이때 자식 클래스에서 추상화 메서드를 오버라이딩해서 직접 구현해야 하기 때문에 다이아몬드 문제가 성립하지 않음