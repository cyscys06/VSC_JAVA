제네릭 클래스의 한계
1. 제네릭은 여러가지 타입을 받을 수 있지만 
사용자에게 필요 없는 타입도 같이 올 수 있다는 단점이 있음
2. 제네릭 클래스를 선언하고 메서드를 만들때는 아직 어떤 타입이 올지 정해지지 않았으므로 
특정 클래스의 메서드는 사용 불가능하고, Object클래스의 메서드만 사용 가능함(Object는 최상위 클래스이므로 가능)

해결: 제네릭 클래스가 받을 수 있는 타입을 제한하는 것
<T extends Animal>: 타입 매개변수 T가 Animal과 그 하위 클래스의 타입만 받을 수 있음
-> 컴파일러에서 어떤 타입들이 올지 예상할 수 있으므로, Animal의 메서드를 사용할 수 있음(최소한 Animal은 올 수 있다고 표시돼 있음)


제네릭 메서드: 메서드에 제네릭 기능을 적용한 것
public static <T extends Number> T numberMethod(T t) {}

제네릭 타입과 차이
제네릭 타입은 객체를 생성하는 시점에 타입이 인자로 전달됨
제네릭 메서드는 메서드를 호출하는 시점에 타입이 인자로 전달됨

제네릭 메서드는 객체 메서드(객체를 만들고 나서 사용 가능한 메서드)와 static 메서드에 모두 적용 가능

타입 매개변수는 객체 생성 시점에 타입이 정해지는데, 
static 메서드는 애초에 클래스에 귀속된 메서드이므로 서로 무관함
-> 따라서 타입 매개변수는 static 메서드에 사용 불가


Integer, Double, Long 같은 래퍼 클래스들은 Number 클래스의 자식임

제네릭 메서드도 타입 추론 가능
Integer result2 = GenericMethod.genericMethod(i); // 메서드 호출 부분에 타입 생략


제네릭 타입, 제네릭 메서드 우선순위
-> 제네릭 메서드가 더 우선순위 높음

와일드카드: ?, ! 처럼 특수문자인 것들
-> 여러 타입이 들어올 수 있음 

static void printWildcardV1(Box<?> box) // 일반 메서드에 와일드카드 사용
-> ?는 모든 클래스를 다 받을수 있음
-> 일반 메서드에 간단하게 사용할 수 있어서 제네릭 메서드보다 훨씬 간편함

제네릭 타입/메서드 vs 와일드카드

제네릭 타입이나 메서드는 특정 시점에 그 타입이 정해짐
여기서 특정 시점은 각각 객체가 생성될 때/메서드를 호출할 때임
와일드카드는 이미 타입이 확정된 객체를 받는것

예를들면 제네릭 타입 매개변수를 이용해서 특정 타입의 객체를 만든 후, 그 객체(타입이 확정된)를 와일드카드를 사용한 일반 메서드가 받을 수 있는 것

-> 와일드카드는 단순히 이미 타입이 확정된 객체를 받기만 하는 것, 제네릭 타입/메서드는 자신들이 직접 나서서 타입을 결정하는 것이라 생각하면 됨

상한 와일드카드: 받을수 있는 매개변수의 최대치를 정하는 것
static void printWildcardV2(Box<? extends Animal> box)
-> Animal타입을 포함해서, Animal타입의 하위 타입만 받는다는 뜻 
-> Animal이 상한이므로 Animal의 상위 타입은 안됨

하한 와일드카드: 상한이랑 반대
Box<? super Animal> box
-> Animal타입을 포함해서, Animal타입의 상위 타입만 받는다는 뜻
-> Animal이 하한이므로 Animal의 하위 타입은 안됨

타입 이레이저: 자바의 제네릭 타입이 검파일 시점에서만 존재하고, 런타임일때는 제네릭 정보가 지워지는 것

컴파일 시점에서는 타입 정보가 남아있지만 런타임 시점에는 타입 정보가 모두 사라짐
그때 제네릭 정보가 지워짐

타입 매개변수에 instanceof나 new를 사용하면 런타임 시점에 다 Object가 돼서 개발자 의도랑 달라지는 문제 생김
-> 이 2개 사용 못함

instanceof: 오른쪽의 객체가 왼쪽의 클래스의 객체이면 true, 아니면 false