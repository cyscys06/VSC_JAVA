리스트: 순서 존재, 중복 허용, 인덱스로 접근 가능
-> 순서 필요하거나 중복값 존재할때 사용

세트(앞으로 셋이라 한다): 순서 없음(출력순서가 입력순서와 다를수 있음), 중복 미허용, 빠른 검색 가능
-> 중복 허용 안하고 요소의 유무만 중요할때 사용

셋에 새로운 값을 넣을 때, 기존 값에 중복이 있는지 검색하기 위해 O(n)만큼의 시간이 들어갈 수밖에 없음

해결: 인덱스 안에 인덱스 번호와 같은 값만 들어갈 수 있게 한다면?
ex) 1번 인덱스에는 값 1만 들어감, 5번 인덱스에는 값 5만 들어감
-> 값 1이 셋에 존재하는지 찾으려면 arr[1]만 해주면 됨(arr[1]의 값이 null이면 중복이 아닌거고, null이 아니면 중복인 것)

문제: 배열 크기를 입력값 범위만큼으로 지정해야함 -> 비효율적

해결: 나머지 연산의 활용 -> 
1. 입력값을 나머지연산할 값을 하나 지정하고, 그 값만큼의 크기로 배열을 만듦
2. 입력값이 그 수보다 큰 값이어도 나머지연산하면 작아질 수밖에 없음 -> 나머지가 해당 배열의 인덱스중 하나에 해당될것(절대 그 수와 같거나 클수 없음)
3. 배열의 인덱스로 사용할수 있게 가공한 값을 해시 인덱스라 함
4. 해시 인덱스와 같은 인덱스에 해당 값 저장
5. 배열 크기를 효율적으로 관리할 수 있음
   
문제: 나머지연산한 값이 같은 원본 값들이 여러개 존재하면?
ex) 1 % 10 = 1, 11 % 10 = 1

해결: 해시 인덱스가 같은 여러 값들을 해시 인덱스와 같은 인덱스 안에 여러개 저장할 수 있게 하기(여러개 저장할 자료구조는 단순배열, 리스트 등등 다양함)
그중 특정 값을 조회하고 싶다면, 해당 인덱스 안에서 모든 값을 한번씩 비교하기
-> O(n)이 걸릴것 같지만 해시 인덱스가 같은 값들이 여러개 존재할 확률은 낮은편이라 O(1)로 봐도됨
contain메서드는 매개변수 값을 순회해서 찾음 -> O(n)이지만 해시충돌 없는경우 값 1개이므로 O(1)임

시간을 줄이려면 해시충돌하는 값들의 개수를 최소화해야함
-> 배열 크기 클수록 해시충돌 발생확률 감소
-> 보통 입력한 데이터 수가 배열크기의 75%를 넘지 않으면 될 정도로 배열크기 조절함

셋의 구성
add(value): 값 추가. 중복 데이터는 저장 X
contain(value): 중복데이터 확인
remove(value): 값 제거

문제: 지금까지 배운 해시 값은 나머지 연산을 이용한 정수형 값만 사용 가능했음 -> 해시 코드로 문자열은 사용 불가

해결: 문자나 문자열을 숫자로 변환해서 해시로 사용하고, 이를 해시 인덱스와 비교하면 됨
-> char를 int로 변환: 아스키 코드 사용
-> String을 int로 변환: 각 문자의 아스키 코드의 총합 사용

해시함수: 임의 길이의 데이터 입력 받아서 고정 길이의 해시 코드로 변환하는 함수
-> hashcode() 메서드를 오버라이딩해서 여러 자료형을 해시코드로 전환할 수 있게 함

여러 자료형을 받는 클래스 생성후, equals() 메서드 안에서 매개변수 자료형을 그 클래스로 캐스팅 
-> 새로 만들어진 크 클래스 객체에는 캐스팅 이전 값 저장
-> 해당 클래스 객체의 해시코드 hashcode로 구하기

하나의 해시인덱스 안에 여러 값 저장할때도 저장하는 리스트 타입 Object로 하면 여러 종류 값 저장 가능

hashcode 반환값으로 음수 나올수도 있으므로 abs로 양수 만들어주기

셋에 저장할땐 hashcode 사용해서 값 해시코드로 변환,
셋에 저장된 중복값 검사할때는 해시 인덱스를 통해 해당 인덱스 리스트에 접근 후 equals() 오버라이딩해서 하나의 클래스로 통일한후 서로비교